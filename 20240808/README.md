## 20240808 문제

### 백준 [타노스](https://www.acmicpc.net/problem/20310)

- 접근방식

  [은상]
  - 사전순으로 가장 빠르게 만들어지려면 0은 최대한 앞에 위치하고 1은 최대한 뒤에 위치
  1. 앞에서부터 1의 개수의 절반만큼 1 제거
  2. 뒤에서부터 0의 개수의 절반만큼 0 제거
  - S의 길이가 4 이상이고 0과 1의 개수는 짝수이므로 예외 경우 존재 X
  
  [주혜]
  - 0,1 개수 카운팅 후 2로 나눈 수 만큼 0과 1 제거
  - 사전 순으로 나타내야 하기 때문에 1은 앞에서부터 0은 뒤에서부터 제거
  
- 피드백

  [은상]
  - 반복문을 통하여 문자열의 특정 문자를 지울 때 발생할 수 있는 `index 이슈`를 빠르게 해결 → Good!
  - 빠른 접근 Idea 구상과 코드 작성 → Good!
  - 예외 경우까지 고려하며 코드 작성 → Good!
  - `find()`와 `rfind()` 함수를 사용하면 더 간결한 코드 작성 가능
  
  [주혜]
  - 문제를 잘못 이해해서 제거가 아닌 재배치를 함
<br/> 0과 1의 개수의 2로 나눈 수 만큼 0을 붙이고 1을 붙임 -> 잘못된 접근으로 쉬운 문제임에도 시간을 더 씀


### 프로그래머스 [전력망을 둘로 나누기](https://school.programmers.co.kr/learn/courses/30/lessons/86971)

- 접근방식

  [은상]
  - 주어진 전선들을 각각 하나씩 잘라보며 두 전력망이 가지고 있는 송전탑 개수의 차이를 확인할 예정
  - `연결 요소 개수 구하기` 유형 풀이법을 통해 임의의 송전탑이 속한 전력망의 송전탑 개수(a)를 구하면 나머지 전력망의 송전탑 개수(b) 파악 가능
    - `연결 요소 개수 구하기` → `그래프(인접 리스트)`와 `BFS` 알고리즘 이용
  - 두 전력망이 가지고 있는 송전탑 개수 차이는 `abs(a - (n - a))` = `abs(n - 2a)` → 이 값의 최소를 정답으로 반환

  [주혜]
  - 주어지는 wires는 트리 구조 (무조건 하나로 연결) 이기 때문에 절댓값 비교를 위해 wires를 하나씩 끊음<br/>탐색해보지 않고는 알 수 없다고 판단
  - 하나씩 끊고 다시 넣어줘야함
  
- 피드백

  [은상]
  - 빠르게 접근 Idea를 구상 → Good!
  - 실수로 `visited[]` 배열의 값을 true로 바꿔주는 과정을 생략하여 이 부분을 발견하는 데 시간 소비 → 해당 유형을 까먹지 않게 자주 풀어보는 수밖에..
  - `visited[]` 배열을  `bfs()` 함수 내에 `vector`로 선언하면 → 값이 자동으로 false로 초기화되기 때문에 reset 과정 생략 가능
  
  [주혜]
  - 빠른 판단 및 코드 작성 -> Good
  
  
