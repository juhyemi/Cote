## 20240812 문제

### 백준 [최소 힙](https://www.acmicpc.net/problem/1927)

- 접근방식

  [은상]
  - C++의 queue 라이브러리에서 제공하는 priority_queue 사용
  
  [주혜]
  - 0일 경우 최소값 return, 정렬 필요 없는 우선순위 큐 이용하여 현
  
- 피드백

  [은상]
  - C++이 제공하는 어떤 자료 구조를 사용해야 하는지 알고 있다 → Good!
    
    → 다양한 문제를 풀면서 C++에서 제공하는 유용한 자료 구조와 함수들에 대한 범위를 늘리자
  
  [주혜]
  - 빠른 판단과 구현으로 5분컷 -> Good

### 프로그래머스 [조이스틱](https://school.programmers.co.kr/learn/courses/30/lessons/42860)

- 접근방식

  [은상]
  - 알파벳을 변경하는 데 필요한 조이스틱 조작 횟수를 구하는 건 간단하지만
    - 알파벳 ‘O’ 부터 조이스틱을 아래로 조작하는 게 더 빠름
        
        ```cpp
        // 'O' 이상이면 아래로 조작
        if(c > 'N') return 'Z' - c + 1;
        // 아니면 위로 조작
        else return c - 'A';
        ```
        
  - 진짜 문제는 커서 이동 횟수의 최솟값을 구하는 것
    - Case 1. 한 방향으로 모든 문자를 확인할 때
        - 커서 이동 횟수는 `n - 1`  이면서 동시에 최댓값
    - Case 2. 한 방향으로 필요한 만큼 문자를 변경할 때
        - 이 경우는 아래 Case 3에 포함
    - Case 3. 방향을 바꿔가며 문자를 변경할 때
        - 원점을 기준으로 현재 위치를 x, 오른쪽에 위치한 문자 중 ‘A’가 아닌 문자의 위치를 y라고 하면, 커서 이동 횟수의 최솟값은 `min(2 * x + (n - y), 2 * (n - y) + x)`
        - ex. ‘ABABAAAAAABA’
            - ←(2), →(2), →(3)
        - Case 2를 포함하는 예제
        - ex. ‘AAAB’
            - →(0), ←(0), ←(1)
        - ex. ‘BAAA’
            - ←(0), →(0), →(1)
  1. name의 문자를 하나씩 순회하며<br>
     해당 위치의 문자를 바꾸기 위한 조이스틱 조작 횟수를 추가<br>
     Case 3을 고려하여 커서 이동 횟수의 최솟값을 갱신
  2. 커서 이동 횟수의 최솟값을 추가

  [주혜]
  
  
- 피드백

  [은상]
  - 약 2시간 동안 고민하고 결국 해결하지 못한 원인 분석
    - 코드를 작성하기 이전에 내가 생각한 접근 방식에 예외가 없는지 확실하게 확인하지 않아 불필요한 시간을 많이 사용
        - “대충 이렇게 하면 되겠는데?” → 코드를 작성하면서 “아 이러면 안 되는데?” → 반복
    - 문제의 유형이 `그리디 알고리즘`인데, 경험상 까다롭게 경우를 구분할 필요가 없다고 생각 → 여러 Test Case를 만들어보며 예외 경우가 생길 때마다 잘못된 방법으로 접근하고 있다고 생각 → 코드가 산으로 가며 결국 포기
    
    → `그리디 알고리즘`도 Case를 까다롭게 구분하는 경우가 존재할 수 있음을 인지
    
    → 예외까지 고려하여 문제의 Case를 확실하게 나누는 연습이 더 필요 (약점 보완)
    
  - 실전 연습할 때 → 클린 코드보단 우선 최대한 빠르게 문제를 해결하는 습관 신경 쓸 것!
  
  [주혜]
  
