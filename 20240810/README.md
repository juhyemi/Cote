## 20240810 문제

### 백준 [가희와 키워드](https://www.acmicpc.net/problem/22233)

- 접근방식

  [은상]
  
  
  [주혜]
  
- 피드백

  [은상]
  
  
  [주혜]


### 프로그래머스 [체육복](https://school.programmers.co.kr/learn/courses/30/lessons/42862)

- 접근방식

  [은상]
  1. `정답 변수`를 `n`으로 설정
  2. 모든 학생을 1번부터 차례로 순회하며 체육 수업을 들을 수 없으면 `정답 변수 -1`
  - 체육복을 빌릴 수 있는지 판단하기 위해
    - `isReserve[n]`, `isLost[n]` 배열 선언
    - 자신 → 앞 → 뒤 사람의 여벌 여부를 순서대로 확인
    - 뒤 사람의 여벌 여부를 판단할 때는 그 사람의 도난 여부도 함께 고려
  - cf. 이 풀이법은 정렬을 전제로 한다
  - cf. `lost[]` 벡터을 정렬한 이후 `lost[]` 벡터을 순회해도 되지만, 정렬의 시간복잡도는 `O(nlogn)`이기 때문에 → 정렬 없이 모든 학생을 차례로 순회하며 `O(logn)`으로 해결

  [주혜]
  - 체육복 여벌있는 학생 중 잃어버린 학생이 있는지 확인
  - 잃어버린 학생 기준 왼쪽부터 여벌옷 있는 학생 확인
  - check배열로 체육복 소유여부 확인

  
- 피드백

  [은상]
  - 처음 풀었을 때 체육복을 빌려줄 사람의 도난 여부를 먼저 확인하지 않아 오답이 발생했고, 예외 Case를 발견하지 못해 질문 게시판 참고 → `Level 1` 문제임에도 불구하고 문제를 정확하게 파악하지 않아 스스로 풀지 못했다
  - 문제에서 따로 언급이 없으면 예시처럼 항상 정렬된 순서로 입력되지 않는다는 사실을 기억하자
    - 내 풀이 알고리즘은 정렬을 전제로 하는데, 체육 수업 수강 여부를 확인하기 위해 `lost[]` 벡터을 차례로 순회했을 때 오답이 발생
    - `lost[]` 벡터 정렬 후 정답 확인
    - 왜 오답이 발생하는지 파악하기 위해 많은 시간을 소비
  - `isReserve[]` 배열과 `isLost[]` 배열을 하나로 합치면 더 간결한 코드 작성 가능
    - 배열을 `int`로 선언
    - 도난당하고 여분도 없는 경우 → `-1`
    - 나 입을 체육복만 있는 경우 → `0`
    - 여벌이 있는 경우 → `1`
    
    → 배열에 값을 설정하는 단계에서 도난당한 여벌이 있는 학생 처리 가능
  
  [주혜]
  - 파른 판단
  - 전에 풀었던 유형 기억해서 응용

  
  
