## 20241017 문제

### 프로그래머스 [입국심사](https://school.programmers.co.kr/learn/courses/30/lessons/43238)

- 접근방식

  [은상]
  - 입국심사를 위해 주어진 시간을 기준으로 하여 이분탐색 진행
    - `left` 초기값: 1
    - `right` 초기값: `n` * 입국심사가 가장 오래걸리는 심사관의 심사 시간 (→ 입국심사가 가장 오래걸리는 심사관이 모든 인원을 입국심사 하는 경우)
        - 입국심사가 가장 오래걸리는 심사관의 심사 시간을 구하기 위해 주어진 times 배열 정렬
    - 입국심사를 위해 주어진 시간(mid) 내 몇 명의 입국심사가 가능한 지 계산
        - 각 심사관이 주어진 시간동안 확인 가능한 인원의 합
        - 그 값이 n보다 작으면 left = mid + 1
        - 그 값이 n보다 크거나 같으면 정답을 mid로 초기화 후 right = mid - 1
        - left > right일 때까지 반복

  [주혜]
  - 주어진 범위가 커서 이분탐색
  - 최소시간과 최대시간 계산
  - 최소시간이기 때문에 중간값을 기준으로 몇 명이 심사 가능한지 확인
  - n보다 작으면 시간이 부족하다는 뜻 -> 최소시간 증가
  - n보다 크거나 같으면 정답에 넣은 후 남는 시간이 클 수도 있기 때문에 최대시간 감소
  
- 피드백

  [은상]
  - 이분탐색 문제는 어떻게 이분탐색 유형임을 파악하고 접근할 수 있을까?
    - 이분탐색이라는 유형임을 파악하기 위한 힌트?
        - 주어진 값의 범위가 비정상적으로 크다 → 시간초과가 발생할 수밖에 없다
    - 이분탐색이 아닐까? 의심 후 어떤 값을 기준으로 이분탐색을 진행할 수 있는지 고민해보기
  - 이분탐색 접근 Key Point
    1. 이분탐색을 진행할 기준값 정하기
    2. 최소값과 최대값 설정
    3. `이분탐색 틀` 기억!
        
        ```cpp
        while(left <= right) {
        	ll mid = left + (right - left) / 2;
                
        	ll passed = 0; // 입국심사를 통과한 사람 수
        	for(int i=0; i<times.size(); ++i) {
        		passed += (mid / (ll)times[i]);
        	}
                
        	// mid 시간으로 n명 이상을 입국심사 할 수 있을 때 
        	if(passed >= n) {
        		answer = mid;
        		right = mid - 1;
        	}
                
        	// 그렇지 않을 때
        	else {
        		left = mid + 1;
        	}
        }
        ```
 
  [주혜]
  - 쉬운 문제라고 생각하고 덫에 걸림
    ```java
    long answer = 0;
        Arrays.sort(times);
        loop:
        while(n!=0){
            answer++;
            for(int i=0; i<times.length; i++){
                if(answer%times[i]==0) n--;
                if(n==0) break loop;
            }
        }
        return answer;
    ```
  - 범위 확인 및 문제 분류 확인 후 이분탐색인 것 확인
  - 문제를 풀 때 신나서 풀지말고 시간 초과가 날 것 같은지부터 확인하자
  
