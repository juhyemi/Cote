## 20240903 문제

### 백준 [N번째 큰 수](https://www.acmicpc.net/problem/2075)

- 접근방식

  [은상]
  - `vector`에 수를 저장 후 정렬을 이용한 풀이 → 메모리 초과
    - 전체를 저장해야 하는 문제가 아니다
    - N번째 숫자만 알면 되므로, 큰 순서대로 N개만 저장하여 그 중 가장 작은 수를 출력하면 된다
    - cf. `vector`에 수를 저장할 때 필요한 총 메모리는 약 9MB 이지만, `vector`의 정렬 과정에서 내부적으로 추가적인 메모리 사용이 발생하기 때문에 메모리 초과가 발생
  - `primary_queue(최소힙)` 사용
    - 큰 순서대로 N개의 수만 저장 → `pq`의 사이즈가 `N`을 넘어가면 `pq.pop()`
    - 마지막에 `N`개 중 가장 작은 수 출력 → `pq.top()`
    - cf. `set`을 이용하는 전략은 성능 면에서 효율적이지 않고, 크기를 제어하는 데 있어 `우선순위 큐`만큼 직접적인 방법이 없기 때문에 더 많은 연산이 필요할 수 있음
  
  [주혜]
  - 하나씩 비교하는건 비효율, 시간초과라 판단
  - 우선순위큐로 받아서 n-1만큼 poll하고 마지막에 poll 값 출력
  
- 피드백

  [은상]
  - 새로 알게 된 지식(벡터 정렬, 메모리)을 기억하고, 다양한 자료구조를 많이 사용해 볼 것
  
  [주혜]
  - 우선순위 큐 생각해낸 것 굿~!
  

### 프로그래머스 [N으로 표현](https://school.programmers.co.kr/learn/courses/30/lessons/42895)

- 접근방식

  [은상]
  - `dp[i]`: i개의 N으로 만들 수 있는 수들을 저장
    - 저장할 때 `unordered_set` 자료 구조 사용
    - 중복과 정렬이 필요 없고, 각 `index` 내 `number`을 찾는 과정에서 시간복잡도가 유리하기 때문
  - `cnt`를 1부터 8까지 순서대로 살펴보며
    - `cnt`개의 N을 이어붙여 만들 수 있는 수도 `dp[cnt]`에 저장
    - `i + j = cnt`일 때 `dp[i] (사칙연산) dp[j] = dp[cnt]`를 만족하는 경우를 저장
    - 저장 후, `dp[cnt]`에 `number`가 있으면 `cnt`를 반환하고 종료
  - `dp[8]`까지 `number`이 없다면 문제 조건에 따라 `-1`을 출력하고 종료
  

  [주혜]
  
  
- 피드백

  [은상]
  - `dp[]`에 어떤 정보를 넣어야 하는지 알 수 있는 힌트가 있었다면
    - 문제 조건 중 `최솟값이 8보다 크면 -1을 return 합니다.`
    
    → 문제를 꼼꼼히 읽어볼 것
    
  - 배열과 자료 구조를 혼합해서 사용하는 문제 유형이 있음을 기억할 것
  
  [주혜]
  
